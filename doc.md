# Random Number Generator (RNG) Assignment Documentation

## 1. Description of the RNG

For this assignment, I implemented a Linear Congruential Generator (LCG), which is one of the oldest and most well-known pseudorandom number generation algorithms. The LCG follows the recurrence relation:

```
X_{n+1} = (a * X_n + c) mod m
```

Where:
- `X_n` is the current state
- `X_{n+1}` is the next state
- `a` is the multiplier
- `c` is the increment
- `m` is the modulus

### Key Lines That Generate Randomness

The core of the randomness generation is in the `next()` method of the LCG class:

```python
def next(self):
    """Generate next random number"""
    self.state = (self.a * self.state + self.c) % self.m
    return self.state
```

This recursive formula creates a sequence of pseudo-random integers that can then be scaled to the range [0,1) by dividing by the modulus:

```python
def next_float(self):
    """Generate next random number in [0,1)"""
    return self.next() / self.m
```

## 2. Parameters Used

For this implementation, I used the following parameters:

- **Seed**: 12345 (initial value)
- **Multiplier (a)**: 1664525
- **Increment (c)**: 1013904223
- **Modulus (m)**: 2^32 (4294967296)

These parameters were chosen because they're commonly used in numerical simulations and were recommended in "Numerical Recipes" by Press et al. They provide a relatively long period and good statistical properties for a simple LCG.

## 3. Chi-Square Test Results

The Chi-square test was used to determine if the values generated by our LCG follow a uniform distribution. The test compares the observed frequencies of values in different intervals with the expected frequencies if the data were truly uniform.

The null hypothesis is that there is no difference between the observed and expected frequencies, indicating a uniform distribution.

Results:
- Chi-square statistic: 5.92
- Degrees of freedom: 9
- p-value: 0.747

Since the p-value is much greater than 0.05, we fail to reject the null hypothesis. This suggests that the distribution of our LCG values is not significantly different from a uniform distribution, which is what we want for a good RNG.

## 4. Comparison with R's Random Generator

The chi-square test comparing our LCG and R's built-in uniform random number generator showed:
- Chi-square statistic: 7.04
- Degrees of freedom: 9
- p-value: 0.633

This high p-value indicates that there's no significant difference between the distribution of numbers from our LCG and R's generator. Both appear to produce distributions that are acceptably uniform.

## 5. RNG vs. RVG Understanding

In this assignment, we're primarily evaluating the quality of a Random Number Generator (RNG) rather than a Random Variable Generator (RVG). Here's the distinction:

- **Random Number Generator (RNG)**: Produces sequences of numbers that exhibit properties of statistical randomness. These are typically uniformly distributed in a specific range (like [0,1)). The LCG we implemented is an RNG.

- **Random Variable Generator (RVG)**: Takes uniform random numbers from an RNG and transforms them to follow other probability distributions (normal, exponential, etc.). This is often done using techniques like inverse transform sampling or Box-Muller transform.

In our tests, we're analyzing whether our LCG produces numbers that are sufficiently uniform and random, which is an evaluation of the RNG quality. We're not transforming these numbers to other distributions, which would be RVG functionality.

## 6. Observations from Graphs

### Histogram
The histogram of LCG values shows a fairly even distribution across all bins, which is consistent with a uniform distribution. There are no obvious peaks or valleys that would indicate non-uniformity.

### Scatter Plot (n vs n+1)
The scatter plot of consecutive values (n vs n+1) shows points distributed throughout the square without any obvious patterns or empty regions. This is a good indication that there's no strong correlation between consecutive numbers.

### 3D Scatter Plot (n vs n+1 vs n+2)
The 3D plot of triplets of consecutive values also shows points distributed throughout the unit cube without apparent patterns. This suggests that there are no discernible patterns in sequences of three consecutive values.

## 7. Drunk Man's Walk Algorithm Analysis

### Correct Implementation (LCG)
The drunk man's walk using our LCG values produces a path that resembles a true random walk. The path:
- Is irregular and unpredictable
- Covers a reasonable area
- Shows no obvious patterns or preferred directions
- Appears to meander naturally, as expected with a random process

This correct behavior indicates that our LCG is producing values that are sufficiently random for this application.

### Incorrect Implementation (Bad RNG)
When using the intentionally poor RNG (which adds 0.1 to the previous value and takes the modulo 1), the drunk man's walk shows clear patterns:
- The path is highly structured and predictable
- It follows a repetitive pattern where the man walks in a cyclic sequence of directions
- The path covers a more limited area
- The walk eventually returns to previous positions and repeats

These observations clearly illustrate how a poor RNG leads to non-random behavior in simulations. The walk isn't truly random because the underlying values are generated in a deterministic pattern.

## Conclusion

The LCG implementation provides a reasonable quality of randomness for basic simulations and applications. It passes statistical tests for uniformity and shows no obvious patterns in visual inspection. However, it's worth noting that LCGs do have limitations and more sophisticated applications might require more advanced RNGs like Mersenne Twister or cryptographic RNGs.

The comparison between the correct LCG implementation and the intentionally poor RNG clearly demonstrates the importance of using quality random number generators in simulations and modeling.